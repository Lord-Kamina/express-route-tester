{"version":3,"sources":["node_modules/browser-pack/_prelude.js","index.js","node_modules/debounce/index.js","versions/0.1.7/index.js","versions/6.2.1/index.js","versions/2.4.0/node_modules/path-to-regexp/index.js","versions/2.0.0/node_modules/path-to-regexp/index.js","versions/3.0.0/node_modules/path-to-regexp/index.js","versions/1.7.0/node_modules/path-to-regexp/index.js","versions/0.1.7/node_modules/path-to-regexp/index.js","versions/5.0.0/node_modules/path-to-regexp/dist/index.js","versions/6.2.1/node_modules/path-to-regexp/dist/index.js","versions/1.7.0/node_modules/isarray/index.js"],"names":["escape","str","replace","hide","selector","elements","document","querySelectorAll","i","length","style","display","show","updateOptions","e","target","id","opts","strict","checked","sensitive","end","start","delimiter","value","prefixes","endsWith","update","setVersion","console","log","_","pathRegexp","versions","keys","regexp","innerHTML","message","textContent","toString","map","key","name","optional","join","updatePath","path","test","result","exec","debounce","require","0.1.7","1.7.0","2.0.0","2.4.0","3.0.0","5.0.0","6.2.1","querySelector","bind","addEventListener","func","wait","immediate","later","last","Date","now","timestamp","timeout","setTimeout","apply","context","args","debounced","this","arguments","callNow","clear","clearTimeout","flush","module","exports","pathToRegexp","parse","options","res","tokens","index","defaultDelimiter","DEFAULT_DELIMITER","delimiters","DEFAULT_DELIMITERS","pathEscaped","PATH_REGEXP","m","escaped","offset","slice","prev","next","capture","group","modifier","k","indexOf","push","partial","undefined","repeat","pattern","prefix","escapeGroup","escapeString","substr","compile","tokensToFunction","matches","Array","RegExp","data","encode","encodeURIComponent","token","segment","isArray","TypeError","j","String","flags","regexpToRegexp","groups","source","match","arrayToRegexp","parts","stringToRegexp","tokensToRegExp","concat","route","isEndDelimited","whitelist","c","endToken","asterisk","encodeURIComponentPretty","encodeURI","charCodeAt","toUpperCase","encodeAsterisk","obj","pretty","isarray","JSON","stringify","attachKeys","re","endsWithDelimiter","pathtoRegexp","extraOffset","keysOffset","MATCHING_GROUP_REGEXP","slash","format","star","len","escapeCount","charAt","splice","balanced","open","close","count","_a","_b","isEscaped","code","validPattern","char","reFlags","x","validate","typeOfMessage","regexpToFunction","decode","pathname","params","Object","create","split","paths","tokensToRegexp","_c","_d","_i","tokens_1","defineProperty","lexer","type","defaultPattern","tryConsume","mustConsume","nextType","consumeText","suffix","name_1","pattern_1","groupsRegex","execResult","_e","_f","endsWithRe","delimiterRe","mod","arr","prototype","call"],"mappings":"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","file":"bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","'use strict'\n\nvar debounce = require('debounce')\n\nvar pathRegexp\nvar versions = {\n  '0.1.7': require('./versions/0.1.7'),\n  '1.7.0': require('./versions/1.7.0'),\n  '2.0.0': require('./versions/2.0.0'),\n  '2.4.0': require('./versions/2.4.0'),\n  '3.0.0': require('./versions/3.0.0'),\n  '5.0.0': require('./versions/5.0.0'),\n  '6.2.1': require('./versions/6.2.1')\n}\n\nvar _ = document.querySelector.bind(document)\n\nfunction escape (str) {\n  str = '' + str\n  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\\\"/g, '&quot;') // eslint-disable-line no-useless-escape\n}\nfunction hide (selector) {\n  var elements = document.querySelectorAll(selector)\n  for (var i = 0; i < elements.length; i++) {\n    elements[i].style.display = 'none'\n  }\n}\nfunction show (selector) {\n  var elements = document.querySelectorAll(selector)\n  for (var i = 0; i < elements.length; i++) {\n    elements[i].style.display = null\n  }\n}\n\n_('#inputStrict').addEventListener('change', updateOptions, false)\n_('#inputSensitive').addEventListener('change', updateOptions, false)\n_('#inputEnd').addEventListener('change', updateOptions, false)\n_('#inputStart').addEventListener('change', updateOptions, false)\n_('#inputDelimiter').addEventListener('change', updateOptions, false)\n_('#inputPrefixes').addEventListener('change', updateOptions, false)\n_('#inputEndsWith').addEventListener('change', updateOptions, false)\n\n_('#inputVersion').addEventListener('change', setVersion, false)\n_('#inputRoute').addEventListener('input', debounce(update, 100), false)\n_('#inputPath').addEventListener('input', debounce(updatePath, 100), false)\n\nvar opts = {\n  strict: false,\n  sensitive: false,\n  end: true,\n  start: true,\n  delimiter: \"/#?\",\n  prefixes: \"/.\",\n  endsWith: \"\"\n}\nfunction updateOptions (e) {\n  switch (e.target.id) {\n    case 'inputStrict':\n      opts.strict = e.target.checked\n      break\n    case 'inputSensitive':\n      opts.sensitive = e.target.checked\n      break\n    case 'inputEnd':\n      opts.end = e.target.checked\n      break\n    case 'inputStart':\n      opts.start = e.target.checked\n      break\n    case 'inputDelimiter':\n      opts.delimiter = e.target.value\n      break\n    case 'inputPrefixes':\n      opts.prefixes = e.target.value\n      break\n    case 'inputEndsWith':\n      opts.endsWith = e.target.value\n      break\n  }\n  update()\n}\n\nfunction setVersion () {\n  console.log(\"_('#inputVersion').value: \" + _('#inputVersion').value)\n  pathRegexp = versions[_('#inputVersion').value] || pathRegexp\n  console.log(pathRegexp)\n  update()\n}\n\nvar keys, regexp\nfunction update () {\n  keys = []\n  try {\n    regexp = pathRegexp(_('#inputRoute').value, keys, opts)\n  } catch (e) {\n    show('.is-error')\n    hide('.is-not-match')\n    hide('.is-match')\n    _('#keys-results-display').innerHTML = '<pre><code>' + e.message + '</code></pre>'\n    return\n  }\n  _('#keys-results-display').innerHTML = ''\n  hide('.is-error')\n  _('#regexp-display').textContent = regexp.toString()\n  if (keys.length) {\n    _('#keys-display').innerHTML = '<ol>' + keys.map(function wrap (key) {\n      return '<li>' + escape(key.name) + (key.optional ? ' (optional)' : '') + '</li>'\n    }).join('') + '</ol>'\n  } else {\n    _('#keys-display').innerHTML = 'There are no keys captured by this route'\n  }\n  updatePath()\n}\nfunction updatePath () {\n  var path = _('#inputPath').value\n  if (regexp.test(path)) {\n    hide('.is-not-match')\n    show('.is-match')\n    var result = regexp.exec(path)\n    _('#keys-results-display').innerHTML = '<dl class=\"dl-horizontal\">' + keys.map(function (key, i) {\n      return '<dt>' + escape(key.name) + '</dt><dd>' +\n      (result[i + 1] ? escape(result[i + 1]) : '&nbsp;') + '</dd>'\n    }).join('') + '</dl>'\n  } else {\n    show('.is-not-match')\n    hide('.is-match')\n  }\n}\nsetVersion()\n","/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\nfunction debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  };\n\n  var debounced = function(){\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n  \n  debounced.flush = function() {\n    if (timeout) {\n      result = func.apply(context, args);\n      context = args = null;\n      \n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n\n// Adds compatibility for ES modules\ndebounce.debounce = debounce;\n\nmodule.exports = debounce;\n","module.exports = require('path-to-regexp')\n","module.exports = require('path-to-regexp').pathToRegexp\n","/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * Default configs.\n */\nvar DEFAULT_DELIMITER = '/'\nvar DEFAULT_DELIMITERS = './'\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \":test(\\\\d+)?\" => [\"test\", \"\\d+\", undefined, \"?\"]\n  // \"(\\\\d+)\"  => [undefined, undefined, \"\\d+\", undefined]\n  '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER\n  var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS\n  var pathEscaped = false\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) !== null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      pathEscaped = true\n      continue\n    }\n\n    var prev = ''\n    var next = str[index]\n    var name = res[2]\n    var capture = res[3]\n    var group = res[4]\n    var modifier = res[5]\n\n    if (!pathEscaped && path.length) {\n      var k = path.length - 1\n\n      if (delimiters.indexOf(path[k]) > -1) {\n        prev = path[k]\n        path = path.slice(0, k)\n      }\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n      pathEscaped = false\n    }\n\n    var partial = prev !== '' && next !== undefined && next !== prev\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = prev || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prev,\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'\n    })\n  }\n\n  // Push any remaining characters.\n  if (path || index < str.length) {\n    tokens.push(path + str.substr(index))\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (data, options) {\n    var path = ''\n    var encode = (options && options.encode) || encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n        continue\n      }\n\n      var value = data ? data[token.name] : undefined\n      var segment\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) continue\n\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j], token)\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        segment = encode(String(value), token)\n\n        if (!matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"')\n        }\n\n        path += token.prefix + segment\n        continue\n      }\n\n      if (token.optional) {\n        // Prepend partial segment prefixes.\n        if (token.partial) path += token.prefix\n\n        continue\n      }\n\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + (token.repeat ? 'an array' : 'a string'))\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$/()])/g, '\\\\$1')\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {Array=}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  if (!keys) return path\n\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        pattern: null\n      })\n    }\n  }\n\n  return path\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options))\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var start = options.start !== false\n  var end = options.end !== false\n  var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER)\n  var delimiters = options.delimiters || DEFAULT_DELIMITERS\n  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|')\n  var route = start ? '^' : ''\n  var isEndDelimited = tokens.length === 0\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n      isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1\n    } else {\n      var capture = token.repeat\n        ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*'\n        : token.pattern\n\n      if (keys) keys.push(token)\n\n      if (token.optional) {\n        if (token.partial) {\n          route += escapeString(token.prefix) + '(' + capture + ')?'\n        } else {\n          route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?'\n        }\n      } else {\n        route += escapeString(token.prefix) + '(' + capture + ')'\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += '(?:' + delimiter + ')?'\n\n    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')'\n  } else {\n    if (!strict) route += '(?:' + delimiter + '(?=' + endsWith + '))?'\n    if (!isEndDelimited) route += '(?=' + delimiter + '|' + endsWith + ')'\n  }\n\n  return new RegExp(route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {Array=}                keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys)\n  }\n\n  if (Array.isArray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), keys, options)\n}\n","/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\"]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined]\n  '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = (options && options.delimiter) || '/'\n  var delimiters = (options && options.delimiters) || './'\n  var pathEscaped = false\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) !== null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      pathEscaped = true\n      continue\n    }\n\n    var prev = ''\n    var next = str[index]\n    var name = res[2]\n    var capture = res[3]\n    var group = res[4]\n    var modifier = res[5]\n\n    if (!pathEscaped && path.length) {\n      var k = path.length - 1\n\n      if (delimiters.indexOf(path[k]) > -1) {\n        prev = path[k]\n        path = path.slice(0, k)\n      }\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n      pathEscaped = false\n    }\n\n    var partial = prev !== '' && next !== undefined && next !== prev\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = prev || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prev,\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'\n    })\n  }\n\n  // Push any remaining characters.\n  if (path || index < str.length) {\n    tokens.push(path + str.substr(index))\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (data, options) {\n    var path = ''\n    var encode = (options && options.encode) || encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n        continue\n      }\n\n      var value = data ? data[token.name] : undefined\n      var segment\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) continue\n\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        segment = encode(String(value))\n\n        if (!matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"')\n        }\n\n        path += token.prefix + segment\n        continue\n      }\n\n      if (token.optional) {\n        // Prepend partial segment prefixes.\n        if (token.partial) path += token.prefix\n\n        continue\n      }\n\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + (token.repeat ? 'an array' : 'a string'))\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$/()])/g, '\\\\$1')\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {Array=}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  if (!keys) return path\n\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        pattern: null\n      })\n    }\n  }\n\n  return path\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options))\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|')\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      if (keys) keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a delimiter at the end of a match.\n  if (!strict) {\n    route += '(?:' + delimiter + '(?=' + endsWith + '))?'\n  }\n\n  if (end) {\n    route += endsWith === '$' ? endsWith : '(?=' + endsWith + ')'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += '(?=' + delimiter + '|' + endsWith + ')'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {Array=}                keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys)\n  }\n\n  if (Array.isArray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), keys, options)\n}\n","/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * Default configs.\n */\nvar DEFAULT_DELIMITER = '/'\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \":test(\\\\d+)?\" => [\"test\", \"\\d+\", undefined, \"?\"]\n  // \"(\\\\d+)\"  => [undefined, undefined, \"\\d+\", undefined]\n  '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER\n  var whitelist = (options && options.whitelist) || undefined\n  var pathEscaped = false\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) !== null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      pathEscaped = true\n      continue\n    }\n\n    var prev = ''\n    var name = res[2]\n    var capture = res[3]\n    var group = res[4]\n    var modifier = res[5]\n\n    if (!pathEscaped && path.length) {\n      var k = path.length - 1\n      var c = path[k]\n      var matches = whitelist ? whitelist.indexOf(c) > -1 : true\n\n      if (matches) {\n        prev = c\n        path = path.slice(0, k)\n      }\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n      pathEscaped = false\n    }\n\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var pattern = capture || group\n    var delimiter = prev || defaultDelimiter\n\n    tokens.push({\n      name: name || key++,\n      prefix: prev,\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: pattern\n        ? escapeGroup(pattern)\n        : '[^' + escapeString(delimiter === defaultDelimiter ? delimiter : (delimiter + defaultDelimiter)) + ']+?'\n    })\n  }\n\n  // Push any remaining characters.\n  if (path || index < str.length) {\n    tokens.push(path + str.substr(index))\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (data, options) {\n    var path = ''\n    var encode = (options && options.encode) || encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n        continue\n      }\n\n      var value = data ? data[token.name] : undefined\n      var segment\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) continue\n\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j], token)\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        segment = encode(String(value), token)\n\n        if (!matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"')\n        }\n\n        path += token.prefix + segment\n        continue\n      }\n\n      if (token.optional) continue\n\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + (token.repeat ? 'an array' : 'a string'))\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$/()])/g, '\\\\$1')\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {Array=}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  if (!keys) return path\n\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return path\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options))\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var start = options.start !== false\n  var end = options.end !== false\n  var delimiter = options.delimiter || DEFAULT_DELIMITER\n  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|')\n  var route = start ? '^' : ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var capture = token.repeat\n        ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*'\n        : token.pattern\n\n      if (keys) keys.push(token)\n\n      if (token.optional) {\n        if (!token.prefix) {\n          route += '(' + capture + ')?'\n        } else {\n          route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?'\n        }\n      } else {\n        route += escapeString(token.prefix) + '(' + capture + ')'\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += '(?:' + escapeString(delimiter) + ')?'\n\n    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')'\n  } else {\n    var endToken = tokens[tokens.length - 1]\n    var isEndDelimited = typeof endToken === 'string'\n      ? endToken[endToken.length - 1] === delimiter\n      : endToken === undefined\n\n    if (!strict) route += '(?:' + escapeString(delimiter) + '(?=' + endsWith + '))?'\n    if (!isEndDelimited) route += '(?=' + escapeString(delimiter) + '|' + endsWith + ')'\n  }\n\n  return new RegExp(route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {Array=}                keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys)\n  }\n\n  if (Array.isArray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), keys, options)\n}\n","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n","/**\n * Expose `pathtoRegexp`.\n */\n\nmodule.exports = pathtoRegexp;\n\n/**\n * Match matching groups in a regular expression.\n */\nvar MATCHING_GROUP_REGEXP = /\\((?!\\?)/g;\n\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String|RegExp|Array} path\n * @param  {Array} keys\n * @param  {Object} options\n * @return {RegExp}\n * @api private\n */\n\nfunction pathtoRegexp(path, keys, options) {\n  options = options || {};\n  keys = keys || [];\n  var strict = options.strict;\n  var end = options.end !== false;\n  var flags = options.sensitive ? '' : 'i';\n  var extraOffset = 0;\n  var keysOffset = keys.length;\n  var i = 0;\n  var name = 0;\n  var m;\n\n  if (path instanceof RegExp) {\n    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\n      keys.push({\n        name: name++,\n        optional: false,\n        offset: m.index\n      });\n    }\n\n    return path;\n  }\n\n  if (Array.isArray(path)) {\n    // Map array parts into regexps and return their source. We also pass\n    // the same keys and options instance into every generation to get\n    // consistent matching groups before we join the sources together.\n    path = path.map(function (value) {\n      return pathtoRegexp(value, keys, options).source;\n    });\n\n    return new RegExp('(?:' + path.join('|') + ')', flags);\n  }\n\n  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))\n    .replace(/\\/\\(/g, '/(?:')\n    .replace(/([\\/\\.])/g, '\\\\$1')\n    .replace(/(\\\\\\/)?(\\\\\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {\n      slash = slash || '';\n      format = format || '';\n      capture = capture || '([^\\\\/' + format + ']+?)';\n      optional = optional || '';\n\n      keys.push({\n        name: key,\n        optional: !!optional,\n        offset: offset + extraOffset\n      });\n\n      var result = ''\n        + (optional ? '' : slash)\n        + '(?:'\n        + format + (optional ? slash : '') + capture\n        + (star ? '((?:[\\\\/' + format + '].+?)?)' : '')\n        + ')'\n        + optional;\n\n      extraOffset += result.length - match.length;\n\n      return result;\n    })\n    .replace(/\\*/g, function (star, index) {\n      var len = keys.length\n\n      while (len-- > keysOffset && keys[len].offset > index) {\n        keys[len].offset += 3; // Replacement length minus asterisk length.\n      }\n\n      return '(.*)';\n    });\n\n  // This is a workaround for handling unnamed matching groups.\n  while (m = MATCHING_GROUP_REGEXP.exec(path)) {\n    var escapeCount = 0;\n    var index = m.index;\n\n    while (path.charAt(--index) === '\\\\') {\n      escapeCount++;\n    }\n\n    // It's possible to escape the bracket.\n    if (escapeCount % 2 === 1) {\n      continue;\n    }\n\n    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\n      keys.splice(keysOffset + i, 0, {\n        name: name++, // Unnamed matching groups must be consistently linear.\n        optional: false,\n        offset: m.index\n      });\n    }\n\n    i++;\n  }\n\n  // If the path is non-ending, match until the end or a slash.\n  path += (end ? '$' : (path[path.length - 1] === '/' ? '' : '(?=\\\\/|$)'));\n\n  return new RegExp(path, flags);\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Default configs.\n */\nvar DEFAULT_DELIMITER = \"/\";\n/**\n * Balanced bracket helper function.\n */\nfunction balanced(open, close, str, index) {\n    var count = 0;\n    var i = index;\n    while (i < str.length) {\n        if (str[i] === \"\\\\\") {\n            i += 2;\n            continue;\n        }\n        if (str[i] === close) {\n            count--;\n            if (count === 0)\n                return i + 1;\n        }\n        if (str[i] === open) {\n            count++;\n        }\n        i++;\n    }\n    return -1;\n}\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var _a, _b;\n    var tokens = [];\n    var defaultDelimiter = (_a = options.delimiter, (_a !== null && _a !== void 0 ? _a : DEFAULT_DELIMITER));\n    var whitelist = (_b = options.whitelist, (_b !== null && _b !== void 0 ? _b : undefined));\n    var i = 0;\n    var key = 0;\n    var path = \"\";\n    var isEscaped = false;\n    // tslint:disable-next-line\n    while (i < str.length) {\n        var prefix = \"\";\n        var name = \"\";\n        var pattern = \"\";\n        // Ignore escaped sequences.\n        if (str[i] === \"\\\\\") {\n            i++;\n            path += str[i++];\n            isEscaped = true;\n            continue;\n        }\n        if (str[i] === \":\") {\n            while (++i < str.length) {\n                var code = str.charCodeAt(i);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[i];\n                    continue;\n                }\n                break;\n            }\n            // False positive on param name.\n            if (!name)\n                i--;\n        }\n        if (str[i] === \"(\") {\n            var end = balanced(\"(\", \")\", str, i);\n            // False positive on matching brackets.\n            if (end > -1) {\n                pattern = str.slice(i + 1, end - 1);\n                i = end;\n                if (pattern[0] === \"?\") {\n                    throw new TypeError(\"Path pattern must be a capturing group\");\n                }\n                if (/\\((?=[^?])/.test(pattern)) {\n                    var validPattern = pattern.replace(/\\((?=[^?])/, \"(?:\");\n                    throw new TypeError(\"Capturing groups are not allowed in pattern, use a non-capturing group: (\" + validPattern + \")\");\n                }\n            }\n        }\n        // Add regular characters to the path string.\n        if (name === \"\" && pattern === \"\") {\n            path += str[i++];\n            isEscaped = false;\n            continue;\n        }\n        // Extract the final character from `path` for the prefix.\n        if (path.length && !isEscaped) {\n            var char = path[path.length - 1];\n            var matches = whitelist ? whitelist.indexOf(char) > -1 : true;\n            if (matches) {\n                prefix = char;\n                path = path.slice(0, -1);\n            }\n        }\n        // Push the current path onto the list of tokens.\n        if (path.length) {\n            tokens.push(path);\n            path = \"\";\n        }\n        var repeat = str[i] === \"+\" || str[i] === \"*\";\n        var optional = str[i] === \"?\" || str[i] === \"*\";\n        var delimiter = prefix || defaultDelimiter;\n        // Increment `i` past modifier token.\n        if (repeat || optional)\n            i++;\n        tokens.push({\n            name: name || key++,\n            prefix: prefix,\n            delimiter: delimiter,\n            optional: optional,\n            repeat: repeat,\n            pattern: pattern ||\n                \"[^\" + escapeString(delimiter === defaultDelimiter\n                    ? delimiter\n                    : delimiter + defaultDelimiter) + \"]+?\"\n        });\n    }\n    if (path.length)\n        tokens.push(path);\n    return tokens;\n}\nexports.parse = parse;\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\nexports.compile = compile;\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            if (Array.isArray(value)) {\n                if (!token.repeat) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n                }\n                if (value.length === 0) {\n                    if (token.optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                    }\n                    path += (j === 0 ? token.prefix : token.delimiter) + segment;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                }\n                path += token.prefix + segment;\n                continue;\n            }\n            if (token.optional)\n                continue;\n            var typeOfMessage = token.repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n        }\n        return path;\n    };\n}\nexports.tokensToFunction = tokensToFunction;\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\nexports.match = match;\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.repeat) {\n                params[key.name] = m[i].split(key.delimiter).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\nexports.regexpToFunction = regexpToFunction;\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: \"\",\n                delimiter: \"\",\n                optional: false,\n                repeat: false,\n                pattern: \"\"\n            });\n        }\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var strict = options.strict, _a = options.start, start = _a === void 0 ? true : _a, _b = options.end, end = _b === void 0 ? true : _b, _c = options.delimiter, delimiter = _c === void 0 ? DEFAULT_DELIMITER : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;\n    var endsWith = (typeof options.endsWith === \"string\"\n        ? options.endsWith.split(\"\")\n        : options.endsWith || [])\n        .map(escapeString)\n        .concat(\"$\")\n        .join(\"|\");\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var capture = token.repeat\n                ? \"(?:\" + token.pattern + \")(?:\" + escapeString(token.delimiter) + \"(?:\" + token.pattern + \"))*\"\n                : token.pattern;\n            if (keys)\n                keys.push(token);\n            if (token.optional) {\n                if (!token.prefix) {\n                    route += \"(\" + capture + \")?\";\n                }\n                else {\n                    route += \"(?:\" + escapeString(token.prefix) + \"(\" + capture + \"))?\";\n                }\n            }\n            else {\n                route += escapeString(token.prefix) + \"(\" + capture + \")\";\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += \"(?:\" + escapeString(delimiter) + \")?\";\n        route += endsWith === \"$\" ? \"$\" : \"(?=\" + endsWith + \")\";\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? endToken[endToken.length - 1] === delimiter\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += \"(?:\" + escapeString(delimiter) + \"(?=\" + endsWith + \"))?\";\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\" + escapeString(delimiter) + \"|\" + endsWith + \")\";\n        }\n    }\n    return new RegExp(route, flags(options));\n}\nexports.tokensToRegexp = tokensToRegexp;\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp) {\n        return regexpToRegexp(path, keys);\n    }\n    if (Array.isArray(path)) {\n        return arrayToRegexp(path, keys, options);\n    }\n    return stringToRegexp(path, keys, options);\n}\nexports.pathToRegexp = pathToRegexp;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pathToRegexp = exports.tokensToRegexp = exports.regexpToFunction = exports.match = exports.tokensToFunction = exports.compile = exports.parse = void 0;\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \".concat(i));\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \".concat(j));\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \".concat(j));\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \".concat(i));\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \".concat(i));\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\".concat(escapeString(options.delimiter || \"/#?\"), \"]+?\");\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \".concat(nextType, \" at \").concat(index, \", expected \").concat(type));\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\nexports.parse = parse;\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\nexports.compile = compile;\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\".concat(token.pattern, \")$\"), reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not repeat, but got an array\"));\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not be empty\"));\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to be \").concat(typeOfMessage));\n        }\n        return path;\n    };\n}\nexports.tokensToFunction = tokensToFunction;\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\nexports.match = match;\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\nexports.regexpToFunction = regexpToFunction;\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    var index = 0;\n    var execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: \"\",\n            suffix: \"\",\n            modifier: \"\",\n            pattern: \"\",\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\".concat(parts.join(\"|\"), \")\"), flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d, _e = options.delimiter, delimiter = _e === void 0 ? \"/#?\" : _e, _f = options.endsWith, endsWith = _f === void 0 ? \"\" : _f;\n    var endsWithRe = \"[\".concat(escapeString(endsWith), \"]|$\");\n    var delimiterRe = \"[\".concat(escapeString(delimiter), \"]\");\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\".concat(prefix, \"((?:\").concat(token.pattern, \")(?:\").concat(suffix).concat(prefix, \"(?:\").concat(token.pattern, \"))*)\").concat(suffix, \")\").concat(mod);\n                    }\n                    else {\n                        route += \"(?:\".concat(prefix, \"(\").concat(token.pattern, \")\").concat(suffix, \")\").concat(token.modifier);\n                    }\n                }\n                else {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        route += \"((?:\".concat(token.pattern, \")\").concat(token.modifier, \")\");\n                    }\n                    else {\n                        route += \"(\".concat(token.pattern, \")\").concat(token.modifier);\n                    }\n                }\n            }\n            else {\n                route += \"(?:\".concat(prefix).concat(suffix, \")\").concat(token.modifier);\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += \"\".concat(delimiterRe, \"?\");\n        route += !options.endsWith ? \"$\" : \"(?=\".concat(endsWithRe, \")\");\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n            : endToken === undefined;\n        if (!strict) {\n            route += \"(?:\".concat(delimiterRe, \"(?=\").concat(endsWithRe, \"))?\");\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\".concat(delimiterRe, \"|\").concat(endsWithRe, \")\");\n        }\n    }\n    return new RegExp(route, flags(options));\n}\nexports.tokensToRegexp = tokensToRegexp;\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\nexports.pathToRegexp = pathToRegexp;\n//# sourceMappingURL=index.js.map","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n"]}